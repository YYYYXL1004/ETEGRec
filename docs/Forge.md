#### 核心逻辑

该算法采用了 **“前缀分组 + 确定性哈希偏移 + 轮询分配”** 的策略。

设物品的原始离散码为 $C = [c_1, c_2, c_3]$，词表大小为 $K$（即 `code_num`，通常为 256）。

1.  **前缀分组 (Prefix Grouping)**:
    将物品按前缀 $P = (c_1, c_2)$ 进行聚类。对于每一个唯一的前缀 $P_j$，我们得到一组物品索引 $I_j = \{i_1, i_2, \dots, i_m\}$。

2.  **确定性哈希偏移 (Deterministic Hash Offset)**:
    对于每个前缀组 $P_j$，计算一个起始偏移量 $O_j$。公式如下：
    $$ O_j = \text{Adler32}(\text{Stringify}(P_j)) \pmod K $$
    *   **Adler32**: 一种校验和算法，作为确定性哈希函数。它保证了相同的输入（前缀）在任何时间、任何机器（多卡 DDP 环境）上都能得到相同的输出，从而保证训练一致性。
    *   **Mod K**: 将哈希值映射到 $[0, K-1]$ 的索引空间内。

3.  **轮询分配 (Round-Robin Allocation)**:
    对于组内的第 $k$ 个物品（$k \in [0, m-1]$），其修正后的第三层编码 $c'_3$ 计算如下：
    $$ c'_3 = (O_j + k) \pmod K $$

#### 随机性 (Randomness) 的体现

这里的“随机性”并非指真正的随机数生成（如 `random.random()`），而是指 **伪随机散列 (Pseudo-random Hashing)**。

*   由于 `Adler32` 函数的特性，即使两个前缀 $P_a$ 和 $P_b$ 非常相似（例如 `(10, 1)` 和 `(10, 2)`），它们计算出的 $O_a$ 和 $O_b$ 也会差异巨大且无规律。
*   这种特性使得不同组的起始填充位置在 $[0, K-1]$ 空间上呈现出一种“混乱”且“不可预测”的分布状态。

#### 均匀分布 (Uniform Distribution) 的体现

*   **宏观均匀 (Global Uniformity)**: 通过 Hash Offset，不同组的填充“起点”被随机打散到整个空间。这避免了所有组都从索引 0 开始填充，导致低索引位置（如 0, 1, 2...）极其拥挤，而高索引位置闲置的情况。
*   **微观均匀 (Local Uniformity)**: 组内采用 `+i` 的线性轮询。这意味着同一个前缀下的物品会挨个占位，不会在同一个桶内发生碰撞，最大化利用了 $K$ 的空间容量。